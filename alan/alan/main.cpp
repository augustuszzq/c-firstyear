#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>

/// you can add other headers as needed
/// but only headers from the standard library
/// and not the algorithm header

/// do not use using namespace std

/// functions for random number generation, do not alter the declarations
void set_random_seed();
int randn(int n);

/// you can define and use additional functions and structs,
/// add here the declarations for any other functions
/// and/or structs you wish to define and use
/// (the implementation for functions that don't belong to a struct
/// should be added after the main)

/// this is the struct definition for the code maker
/// do not alter the name
struct mm_code_maker{
    
    /// this member function sets the values for the member data
    /// representing the lenght of the code
    /// and the number of symbols (the symbols will be 0 to i_num)
    /// (this should be a constructor in proper OOP but ok)
    /// do not alter this function
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }
    
    /// this member function generates a random sequence based
    /// on the length and num parameters stored as member data
    /// do not alter this function
    void generate_sequence(){
        for(int i = 0; i < length; i++){
            sequence.push_back(randn(num));
        }
    }
    
    /// do not alter name and parameter list for this function
    void give_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){
        black_hits =0;
        white_hits= 0;
        std::vector<int> vt;
        std::vector<int> va;
        bool check;
        for (int i=0; i<attempt.size();i++){
            if (attempt[i]==sequence[i]){
                black_hits++;
            }
            else {
                va.push_back(attempt[i]);
                vt.push_back(sequence[i]);
            }
        }
        
        for (int i=0; i<va.size();i++){
            check= true;
            for (int h=0; h<vt.size()&&check;h++){
                if (va[i]==vt[h]){
                    white_hits++;
                    vt.erase(vt.begin()+h);
                    check = false;
                }
            }
        }
        /// write here your implementation for this function
        /// which takes in input an attempt
        /// and provides feedback in terms of black hits
        /// and white hits (see linked paper)
    }
    
    /// member data holding the sequence generated by generate_sequence
    /// do not alter this
    std::vector<int> sequence;
    
    /// member data holding the values for length of code and number of symbols
    /// do not alter these
    int length;
    int num;
    
    /// do not add any other member data,
    /// in particular note that any variables needed for function give_feedback
    /// need to be declared within give_feedback
    /// (they are not member data of the struct)
    
    /// you may add other member functions if needed
};


/// this is the struct definition for the solver, do not alter the name
struct mm_solver{
    
    /// this member function sets the values for the member data
    /// representing the lenght of the code
    /// and the number of symbols (the symbols will be 0 to i_num)
    /// (this should be a constructor in proper OOP but ok)
    /// do not alter this function
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }
    
    /// this member function creates an attempt to find the right code
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void create_attempt(std::vector<int>& attempt){
        attempt.clear();
        /// write your implementation here
        // bool ready = false;
        // while(!ready){
        if (attempt_list.size()==0){
            attempt.push_back(0);
            attempt.push_back(0);
            attempt.push_back(1);
            attempt.push_back(1);
        }
        else {
            continuedoing=true;
            not_found=false;
            do {
                for (int i =0 ; i<attempt_list.size()&&continuedoing; i++){
                    generate_random(temp);
                    input=attempt_list[i];
                    my_feedback(temp,b,w);
                    input.clear();
                    if ((b==black_list[i])&&(w==white_list[i])){
                        continuedoing= true;
                        not_found=false;
                    }
                    else {
                        continuedoing= false;
                        not_found=true;
                    }
                }
            }while (not_found);
            
            attempt=temp;
        }
        //
        //     bool found = false;
        //     for(int i = 0; i < not_correct.size() && !found; i++){
        //         if(attempt == not_correct[i]){
        //             found = true;
        //         }
        //     }
        //
        //     if(found){
        //         /// the following printing can be used for testing purposes in order
        //         /// to see how much of an improvement this version is on the previous one
        //         /// std::cout << "this was already attempted, resetting" << std::endl;
        //         attempt.clear();
        //     }
        //     else{
        //         ready = true;
        //     }
        // }
    }
    
    /// this member function acquires the feedback about a certain attempt
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void learn(std::vector<int>& attempt, int black_hits, int white_hits){
        attempt_list.push_back(attempt);
        black_list.push_back(black_hits);
        white_list.push_back(white_hits);
    }
    void my_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){
        black_hits =0;
        white_hits= 0;
        std::vector<int> vt;
        std::vector<int> va;
        
        bool check;
        for (int i=0; i<attempt.size();i++){
            if (attempt[i]==input[i]){
                black_hits++;
            }
            else {
                va.push_back(attempt[i]);
                vt.push_back(input[i]);
            }
        }
        
        for (int i=0; i<va.size();i++){
            check= true;
            for (int h=0; h<vt.size()&&check;h++){
                if (va[i]==vt[h]){
                    white_hits++;
                    vt.erase(vt.begin()+h);
                    check = false;
                }
            }
        }
        va.clear();
        vt.clear();
    }
    void generate_random(std::vector<int> &temp){
        temp.clear();
        for(int i = 0; i < length; i++){
            temp.push_back(randn(num));
        }
    }
    //initialize & define parameters
    int length;
    int num;
    int b;
    int w;
    std::vector<std::vector<int> > not_correct;
    std::vector<int> input;
    std::vector<std::vector<int> > attempt_list;
    std::vector<int> black_list;
    std::vector<int> white_list;
    std::vector<int> temp;
    bool continuedoing;
    bool not_found;
    /// you may add other member functions and member data as needed
    /// (keep in mind the distinction between member function variables
    /// and member data of the struct)
    
};

/// before the submission you need to remove the main
/// (either delete it or comment it out)
/// otherwise it will intefere with the automated testing

int main(){
    /// write the code for the main here in order to test your functions
    set_random_seed();
    
    int length, num;
    std::cout << "enter length of sequence and number of possible values:" << std::endl;
    std::cin >> length >> num;
    mm_solver solver;
    solver.init(length, num);
    
    mm_code_maker maker;
    maker.init(length, num);
    maker.generate_sequence();
    
    int black_hits=0, white_hits=0;
    int attempts_limit = 5000;
    int attempts = 0;
    while((black_hits < length) && (attempts < attempts_limit)){
        std::vector<int> attempt;
        solver.create_attempt(attempt);
        maker.give_feedback(attempt, black_hits, white_hits);
        std::cout << "attempt: " << std::endl;
        for(int i = 0; i < attempt.size(); i++){
            std::cout << attempt[i] << " ";
        }
        std::cout << std::endl;
        std::cout << "black pegs: " << black_hits << " " << " white pegs: " << white_hits << std::endl;
        solver.learn(attempt, black_hits, white_hits);
        attempts++;
    }
    
    if(black_hits == length){
        std::cout << "the solver has found the sequence in " << attempts << " attempts" << std::endl;
    }
    else{
        std::cout << "after " << attempts << " attempts still no solution" << std::endl;
    }
    std::cout << "the sequence generated by the code maker was:" << std::endl;
    for(int i = 0; i < maker.sequence.size(); i++){
        std::cout << maker.sequence[i] << " ";
    }
    std::cout << std::endl;
    return 0;
}

/// not a great implementation for set_random_seed and for randn;
/// if you are trying to get better results you may want to change
/// the implementation using C++11 features, see for instance
/// https://isocpp.org/files/papers/n3551.pdf
/// but don't change the interface/declaration of the functions

void set_random_seed(){
    std::srand(std::time(0));
}

int randn(int n){
    return std::rand() % n;
}

/// add here the implementation for any other functions you wish to define and use

